// Generated by CoffeeScript 1.4.0
(function() {
  var Aonyx, PARAM_CLEAN_REGEX, PARAM_REGEX, _, _argumentsFor, _emptyServices, _formatName, _getParamList, _getService, _injectServices, _mergeArguments, _registerService, _removeService, _serviceExists, _serviceFor, _services, _setPrototype,
    __slice = [].slice;

  _ = require('underscore');

  PARAM_REGEX = /^[\s\(]*function[^(]*\(([^)]*)\)/;

  PARAM_CLEAN_REGEX = /\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g;

  _services = {};

  _formatName = function(name) {
    name = name.replace(/\s+/g, '');
    return name = "" + (name.charAt(0).toLowerCase()) + (name.substr(1));
  };

  _serviceFor = function(name, resolver) {
    var formattedName, service;
    service = null;
    formattedName = _formatName(name);
    if (!_serviceExists(formattedName) && typeof resolver === 'function') {
      service = resolver(name);
      return service;
    } else if (!_serviceExists(formattedName)) {
      return null;
    }
    service = _services[formattedName];
    return service;
  };

  _mergeArguments = function(services, args) {
    var k, newServices, v, _i, _len;
    newServices = [];
    for (k = _i = 0, _len = services.length; _i < _len; k = ++_i) {
      v = services[k];
      newServices[k] = v;
      if (!(v != null)) {
        if (args.length > 0) {
          newServices[k] = args.shift();
        }
      }
    }
    if (args.length > 0) {
      newServices = newServices.concat(args);
    }
    return newServices;
  };

  _setPrototype = function(value) {
    if (!value) {
      Function.prototype["injector"] = null;
      delete Function.prototype["injector"];
      Function.prototype["inject"] = null;
      delete Function.prototype["inject"];
    } else {
      Function.prototype["injector"] = function() {
        return _injectServices(this);
      };
      Function.prototype["inject"] = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _injectServices(this).apply(this, args);
      };
    }
  };

  _serviceExists = function(name) {
    name = _formatName(name);
    return name in _services;
  };

  _removeService = function(name) {
    name = _formatName(name);
    if (_serviceExists(name)) {
      _services[name] = null;
      return delete _services[name];
    }
  };

  _emptyServices = function() {
    var key;
    for (key in _services) {
      _services[key] = null;
      delete _services[key];
    }
    return _services = {};
  };

  _getService = function(name) {
    name = _formatName(name);
    if (!_serviceExists(name)) {
      return null;
    }
    return _services[name];
  };

  _registerService = function(name, service) {
    var formattedName;
    formattedName = _formatName(name);
    if (_serviceExists(formattedName)) {
      throw new Error("A service with the name '" + name + "' already exists!");
    }
    if (!_.isObject(service) && !_.isFunction(service)) {
      throw new Error("You can only register an object or a function with aonyx!");
    }
    return _services[formattedName] = service;
  };

  _getParamList = function(method) {
    var match, methodString, params, temp;
    methodString = null;
    if (typeof method === 'string') {
      methodString = method;
    } else if (typeof method === 'function') {
      methodString = method.toString();
    }
    params = [];
    if (!(methodString != null)) {
      return params;
    }
    if (!PARAM_REGEX.test(methodString)) {
      return params;
    }
    match = PARAM_REGEX.exec(methodString);
    if (!(match != null) || match.length === 0) {
      return params;
    }
    temp = match[1].replace(PARAM_CLEAN_REGEX, '').replace(/\s+/g, '');
    return params = temp.split(',');
  };

  _argumentsFor = function() {
    var argList, args, key, method, params, resolve, _i, _j, _len;
    method = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), resolve = arguments[_i++];
    if (resolve == null) {
      resolve = null;
    }
    if (_.isArray(args[0])) {
      args = args[0];
    }
    params = _getParamList(method);
    argList = [];
    for (_j = 0, _len = params.length; _j < _len; _j++) {
      key = params[_j];
      argList.push(_serviceFor(key, resolve));
    }
    argList = _mergeArguments(argList, args);
    return argList;
  };

  _injectServices = function(method) {
    var injector;
    injector = function() {
      var args, serviceList;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      serviceList = _argumentsFor.call(injector, method, args, injector.resolve);
      return method.apply(this, serviceList);
    };
    injector.resolver = function(resolve) {
      return injector.resolve = resolve;
    };
    return injector;
  };

  Aonyx = {
    version: '0.1.0',
    __mergeArguments: _mergeArguments,
    register: _registerService,
    inject: _injectServices,
    "arguments": _argumentsFor,
    params: _getParamList,
    has: _serviceExists,
    get: _getService,
    proto: _setPrototype,
    remove: _removeService,
    empty: _emptyServices
  };

  module.exports = Aonyx;

}).call(this);
